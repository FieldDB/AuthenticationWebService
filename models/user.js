'use strict';
var bcrypt = require('bcrypt');
var crypto = require('crypto');
var debug = require('debug')('user');
var Sequelize = require('sequelize');

var sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'sqlite',
  pool: {
    max: 5,
    min: 0,
    idle: 10000
  },
  storage: 'db/users.sqlite'
});

var DEFAULT_GRAVATAR = '9a85e3d0-4233-11e6-bac0-4b263459491d';

/*
 * Add new properties to the flat schema
 */
var FLAT_SCHEMA = {
  id: {
    type: Sequelize.UUID,
    defaultValue: Sequelize.UUIDV1,
    primaryKey: true
  },
  revision: Sequelize.STRING,
  deletedAt: Sequelize.DATE,
  deletedReason: Sequelize.STRING,
  username: {
    type: Sequelize.STRING,
    unique: true
  },
  email: Sequelize.STRING,
  gravatar: {
    type: Sequelize.STRING,
    get: function() {
      var gravatar = this.getDataValue('gravatar');
      if (gravatar) {
        return gravatar;
      }
      var email = this.getDataValue('email') || this.getDataValue('id') || DEFAULT_GRAVATAR;
      return crypto.createHash('md5').update(email).digest('hex');
    },
  },
  description: Sequelize.TEXT,
  givenName: Sequelize.STRING,
  familyName: Sequelize.STRING,
  language: Sequelize.STRING,
  hash: Sequelize.STRING
};

var User = sequelize.define('users', FLAT_SCHEMA);

/**
 * Convert an incoming json and scrubs it against the above SCHEMA
 * @param  {Object} json A user profile usually coming from the client side for example
 * @return {Object}      A flat representation of the user which can be saved in the db
 */
function jsonToFlat(json, defaultValue) {
  var flat = {};

  json.name = json.name || {};

  for (var attr in FLAT_SCHEMA) {
    if (!FLAT_SCHEMA.hasOwnProperty(attr)) {
      continue;
    }

    if (attr.indexOf('Name') > -1) {
      flat[attr] = json.name[attr] !== undefined && json.name[attr] !== null ?
        json.name[attr] : defaultValue;
    } else {
      flat[attr] = json[attr] !== undefined && json[attr] !== null ?
        json[attr] : defaultValue;
    }
  }

  // use autogenerated id
  if (!flat.id) {
    delete flat.id;
  }

  if (!flat.deletedAt) {
    flat.deletedAt = null;
  }

  if (flat.password) {

  }

  return flat;
}

/**
 * Convert a flat object from the database to a Passport compatible
 * user profile
 * @param  {Object} flat A flat representation usualy from the db
 * @return {Object}      A Passport compatible representation of the user
 */
function flatToJson(flat, defaultValue) {
  var json = {
    name: {}
  };

  for (var attr in FLAT_SCHEMA) {
    if (!FLAT_SCHEMA.hasOwnProperty(attr)) {
      continue;
    }

    if (attr.indexOf('Name') > -1) {
      json.name[attr] = flat[attr] !== undefined && flat[attr] !== null ?
        flat[attr] : defaultValue;
    } else {
      json[attr] = flat[attr] !== undefined && flat[attr] !== null ?
        flat[attr] : defaultValue;
    }
  }

  if (!json.deletedAt) {
    json.deletedAt = null;
  }

  if (flat.createdAt) {
    json.createdAt = flat.createdAt;
  }

  if (flat.updatedAt) {
    json.updatedAt = flat.updatedAt;
  }

  return json;
}

function increaseRevision(revision) {
  var revisionNumber = parseInt(revision.split('-')[0], 10);
  return (revisionNumber + 1) + '-' + Date.now();
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function hashPassword(password) {
  if (!password) {
    return new Error('Please provide a password');
  }

  var salt = bcrypt.genSaltSync(10);
  return {
    salt: salt,
    hash: bcrypt.hashSync(password, salt)
  };
}

/**
 * Create a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function create(profile, callback) {
  if (!profile) {
    return callback(new Error('Please provide a user'));
  }

  if (!profile || !profile.password || profile.password.length < 8) {
    return callback(new Error('Please provide a password which is 8 characters or longer'));
  }

  delete profile.hash;

  var flat = jsonToFlat(profile);

  if (flat.revision) {
    if (flat.revision.indexOf('-') === -1) {
      delete flat.revision;
    } else {
      flat.revision = increaseRevision(flat.revision);
    }
  }
  flat.revision = flat.revision || '1-' + Date.now();

  if (profile.password) {
    var hashed = hashPassword(profile.password);
    if (hashed instanceof Error) {
      return callback(hashed);
    }

    flat.hash = hashed.hash;
  }

  User
    .create(flat)
    .then(function(data) {
      var flat = data.toJSON();
      callback(null, flatToJson(flat, ''));
    })
    .catch(callback);
}

/**
 * Create a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function read(profile, callback) {
  User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function(dbUser) {
      if (!dbUser) {
        return callback(null, null);
      }
      callback(null, flatToJson(dbUser.toJSON(), ''));
    })
    .catch(callback);
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function verifyPassword(profile, callback) {
  if (!profile || !profile.username || !profile.password) {
    return callback(new Error('Please provide a username and a password'));
  }

  User
    .find({
      where: {
        username: profile.username
      },
      // attributes: ['hash']
    })
    .then(function(dbUser) {
      if (!dbUser) {
        return callback(new Error('User not found'));
      }

      if (!dbUser.dataValues.hash) {
        return callback(new Error('User doesn\'t have a password'));
      }

      if (bcrypt.compareSync(profile.password, dbUser.dataValues.hash)) {
        return callback(null, flatToJson(dbUser.toJSON(), ''));
      }

      callback(new Error('Invalid password'));
    })
    .catch(callback);
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function changePassword(profile, callback) {
  if (!profile || !profile.username || !profile.newPassword || !profile.password) {
    return callback(new Error('Please provide a username, password and newPassword'));
  }

  User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function(dbUser) {
      if (!dbUser.dataValues.hash) {
        return callback(new Error('Please set the password before changing it'));
      }

      if (bcrypt.compareSync(profile.password, dbUser.dataValues.hash)) {
        return callback(new Error('Password doesn\'t match your old password'));
      }

      var hashed = hashPassword(profile.newPassword);
      if (hashed instanceof Error) {
        return callback(hashed);
      }

      dbUser.dataValues.hash = hashed.hash;
      dbUser.save().then(function(dbUser) {
        callback(null, flatToJson(dbUser.toJSON(), ''));
      }).catch(callback);
    })
    .catch(callback);
}

/**
 * Save a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function save(profile, callback) {
  if (!profile) {
    return callback(new Error('Please provide a user'));
  }

  User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function(dbUser) {
      // Create the user
      if (!dbUser) {
        return create(profile, callback);
      }

      delete profile.hash;

      var flat = jsonToFlat(profile, 'not:::patched');
      debug(flat);

      // Update only the changed fields
      for (var attr in flat) {
        if (flat.hasOwnProperty(attr) && flat[attr] !== 'not:::patched') {
          dbUser.set(attr, flat[attr]);
          debug('setting ', attr);
        }
      }

      // If the user doesnt have a has yet
      // and the passed in profile had a password,
      // set the hash
      if (profile.password && !dbUser.dataValues.hash) {
        var hashed = hashPassword(profile.password);
        if (hashed instanceof Error) {
          return callback(hashed);
        }

        dbUser.hash = hashed.hash;
      }

      dbUser.set('revision', increaseRevision(dbUser.get('revision')));

      return dbUser
        .save()
        .then(function(savedDbUser) {
          debug(savedDbUser);
          if (!savedDbUser) {
            return callback(new Error('Unable to save the user.'));
          }

          callback(null, flatToJson(savedDbUser.toJSON(), ''));
        })
        .catch(callback);
    })
    .catch(callback);
}

/**
 * List users matching the options
 * @param  {String} options [description]
 * @return {Promise}        [description]
 */
function list(options, callback) {
  options = options || {};
  options.limit = options.limit || 10;
  options.offset = options.offset || 0;
  options.where = options.where || {
    deletedAt: null
  };

  options.attributes = ['id', 'username', 'gravatar'];

  User
    .findAll(options)
    .then(function(users) {
      if (!users) {
        return callback(new Error('Unable to fetch user collection'));
      }

      callback(null, users.map(function(dbUser) {
        return dbUser.toJSON();
      }));
    })
    .catch(callback);
}

/**
 * Delete users matching the options
 * @param  {String} options [description]
 * @return {Promise}        [description]
 */
function flagAsDeleted(profile, callback) {
  if (!profile || !profile.username || !profile.deletedReason) {
    return callback(new Error('Please provide a username and a deletedReason'));
  }

  User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function(dbUser) {
      if (!dbUser) {
        return callback(new Error('Cannot delete user which doesn\'t exist'));
      }

      dbUser.deletedAt = new Date();
      dbUser.deletedReason = profile.deletedReason;

      dbUser
        .save(dbUser)
        .then(function(dbUser) {
          if (!dbUser) {
            return callback(new Error('Save failed'));
          }

          callback(null, dbUser.toJSON());
        })
        .catch(callback);
    });
}

/**
 * Initialize the table if not already present
 * @return {Promise}        [description]
 */
function init() {
  return sequelize.sync();
}

module.exports.create = create;
module.exports.flagAsDeleted = flagAsDeleted;
module.exports.init = init;
module.exports.list = list;
module.exports.save = save;
module.exports.read = read;
module.exports.hashPassword = hashPassword;
module.exports.changePassword = changePassword;
module.exports.verifyPassword = verifyPassword;
module.exports.serialization = {
  flatToJson: flatToJson,
  jsonToFlat: jsonToFlat
};
